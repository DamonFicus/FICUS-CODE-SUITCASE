decorator模式：
核心：
1.继承一个相同的超类（是为了达到模式匹配，这样装饰类才能无感替代被装饰对象）
2.在被装饰对象上做扩展

形式：可以动态添加装饰功能，也可以预设装饰功能
即可以在节点前，节点后，加入扩展的装饰功能

应用场景：
咖啡不同系列制作时，调料，价格，会变化；
通过包装方式去处理，解决只有一个咖啡父类继承的话，囊括所有系列造成的类爆炸的问题；


装饰模式：
动态的将责任附加到对象上，若要扩展功能，装饰者提供了比继承更有弹性的替代方案；


继承是主要是为了拥有正确的类型，而不是为了得到其行为，行为来自装饰者和其组件，或与其他装饰者的组合关系，
组合使其具有之前不具备的能力扩展